1. Haskel oblicza wartość tylko wtedy, gdy jest naprawdę potrzebna dzięki czemu nie marnujemy niepotrzebnie
zasobów komputera(leniwa ewaluacja) + cache'owanie wartości.

2. Możemy tworzyć typy rekurencyjne. Tworzymy typ 0 lub następnik. Przykładowo: 3 
jest zdefiniowana jako następnik następnika następnika zera. Funkcia nat2Int zamienia
typ Nat na Integer.

3.
main :: IO()
main = do
 print(rev [1,2,3,4])
 
rev :: [a] -> [a]
rev x = rev' x [] 

rev' :: [a] -> [a] -> [a]
rev' [] x = x 
rev' (first:rest) x = rev' rest (first:x)

4.
main :: IO()
main = do
 print tabliczka

tabliczka :: [(Integer, Integer, Integer)]
tabliczka = [(x,y,x*y)  | x <- [1..12], y <- [1..12]] //będzie na kolokwium

5.
main :: IO()
main = do
 print(color["black", "white", "blue", "yellow", "red"])

color :: [String] -> [(String, String)]
color [] = []
color (first:rest) = [(first, x) | x <- rest] ++ color rest

6.
a) ++

b)
main :: IO()
main = do 
 print(member "red" ["black", "white", "blue", "yellow", "red"])

member :: Eq a => a -> [a] -> Bool
member x [] = False
member x (first:rest) = x == first || member x rest

c)

d)
main :: IO()
main = do 
 print(delete "red" ["black", "white", "blue", "yellow", "red"])

delete :: Eq a => a -> [a] -> [a]
delete x [] = []
delete x (first:rest)
  | x == first = rest
  | otherwise = first: delete x rest 


